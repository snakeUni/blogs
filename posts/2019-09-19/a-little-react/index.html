<!doctype html><html lang="en"><head><meta charset="utf-8"/><link rel="shortcut icon" href="./fa.jpg"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><meta name="theme-color" content="#000000"/><link rel="manifest" href="./manifest.json"/>
    <title>A little About React</title>
    <link rel="canonical" href="/posts/2019-09-19/a-little-react" />
    <link rel="stylesheet" href="./static/css/1.27c8494b.chunk.css" />
  <link href="./static/css/main.0e6724e3.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="BlogLayout_container__1wjbv"><div class="
        LoadingIndicator_LoadingIndicator__LXZCC
        
        undefined
      "></div><header><h3 class="BlogLayout_title__U0zfd"><a class=" " href="/">lanyincao</a></h3></header><main><article><header class="BlogPostLayout_header__6lPZ1"><h1 class="BlogPostLayout_title__1egAZ"><a class=" " href="/posts/2019-09-19/a-little-react/">A little About React</a></h1><small><time dateTime="Wed, 18 Sep 2019 16:00:00 GMT">September 19, 2019</time> <!-- -->•<!-- --> <ul class="ArticleMeta_tags__30Wbg"><li><a class=" " href="/tags/react/">react</a></li><li><a class=" " href="/tags/little/">little</a></li></ul> <!-- -->•<!-- --> <span>☕️<!-- --> <!-- -->4<!-- --> min read</span></small></header><div class="BlogPostLayout_content__1CRXP"><p>本来是不打算写这篇文章的，但是最近正好遇到了一些问题，或者说是组内遇到了一些问题，就顺便写这篇文章</p><h2 id="目录">目录</h2><ul><li>React Virtual Dom Terminology</li><li>useLayoutEffect and useEffect</li></ul><h2 id="react-virtual-dom-terminology">React Virtual Dom Terminology</h2><p>在 React 中有几个类型需要区分清楚，在同 <code>TS</code> 写的时候也会经常遇到这几种类型</p><ul><li>ReactElement / ReactElement Factory</li><li>ReactNode</li><li>ReactComponent / ReactComponent Class</li></ul><h3 id="react-elements">React Elements</h3><p>在 React 中原始类型就是 ReactElement，ReactElement 有四个属性分别为 <code>type</code>, <code>props</code>, <code>key</code>, <code>ref</code>. 后续 key 有可能会从 props 中
进行剥离. 并且也不存在方法和其他的任何东西在 <code>prototype</code> 上.</p><p>在 React 中可以通过调用 React.createElement 来创建</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> root <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>为了渲染到 DOM 中，需要把创建的 <code>ReactElement</code> 传递给 <code>React.render</code> 并且第二个参数是正常的 DOM 元素比如 <code>HTMLElement</code>, <code>ReactElement</code> 是一个
无状态的，不可突变的，虚拟的 dom element。</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers="">React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果需要传递额外的属性，在 React.createElement 的第二个参数传递提个对象，第三个参数是一个 child</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> child <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'text'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> root <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> className<span class="token punctuation">:</span> <span class="token string">'my-root'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果使用 <code>JSX</code>, 那么这样写也是一样的</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">'my-root'</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>text<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h4 id="factory">Factory</h4><p>一个 <code>ReactElement</code> 的工厂是一个简单的用来创建 <code>ReactElement</code> 带着特定的 <code>type</code>。React 本身内部是有这样的一个函数的。</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">createFactory</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>这样可以快速创建一个带有类型的函数，然后在此调用函数，不需要在传递额外的类型。比如不在需要每次都传入类型 <code>React.createElement(&#x27;type&#x27;)</code></p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> div <span class="token operator">=</span> <span class="token function">createFactory</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">{</span> className<span class="token punctuation">:</span> <span class="token string">'my-root'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果使用的是 <code>JSX</code> 的话，那么根本不需要这么做， React 内部已经处理好了。</p><h3 id="react-nodes">React Nodes</h3><p><code>React Node</code> 可能是其中的一种：</p><ul><li>React Element</li><li>string</li><li>number</li><li>ReactFrament</li></ul><p>可以直接看 ReactNode 的定义</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers="">type ReactNode <span class="token operator">=</span>
  <span class="token operator">|</span> ReactChild
  <span class="token operator">|</span> ReactFragment
  <span class="token operator">|</span> ReactPortal
  <span class="token operator">|</span> boolean
  <span class="token operator">|</span> <span class="token keyword">null</span>
  <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre><p>相关类型的定义</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers="">type ReactText <span class="token operator">=</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
type ReactChild <span class="token operator">=</span> ReactElement <span class="token operator">|</span> ReactText<span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">ReactNodeArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span>ReactNode<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
type ReactFragment <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> ReactNodeArray<span class="token punctuation">;</span>
</code></pre><p><code>React Element</code></p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">ReactElement</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> any<span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">string</span> <span class="token operator">|</span> JSXElementConstructor<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">=</span> string <span class="token operator">|</span> JSXElementConstructor<span class="token operator">&lt;</span>any<span class="token operator">>></span> <span class="token punctuation">{</span>
      type<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
      props<span class="token punctuation">:</span> <span class="token constant">P</span><span class="token punctuation">;</span>
      key<span class="token punctuation">:</span> Key <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><h3 id="react-components">React Components</h3><p>一个 <code>React Components</code> Class 就是一个简单的 js class</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>当这个构造函数被调用的时候，将返回一个对象，并且一定要有一个 <code>render</code> 函数在内部。这个对象就是 <code>ReactComponent</code></p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// never do this</span>
</code></pre><p>除非是为了测试，否则千万不要这么写。React 会在内部调用的。Dan 也在<a class=" " href="https://overreacted.io/how-does-react-tell-a-class-from-a-function/">之前的文章</a>中说过原因</p><p>也可以把 <code>ReactComponent</code> class 传递给 React.createElement 得到一个 ReactElement</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> element <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>也可以使用 <code>JSX</code> 的方式</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token operator">&lt;</span>MyComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
</code></pre><p>当这个被传递给 <code>React.render</code> 时，React 将调用构造函数并且返回一个 <code>ReactComponent</code></p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> component <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果继续调用 <code>React.render</code> 带着相同的 <code>ReactElement</code> 和相同的 dom, 那么总是返回相同的实例</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token keyword">const</span> componentA <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> componentB <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
componentA <span class="token operator">===</span> componentB<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><h2 id="uselayouteffect--useeffect">useLayoutEffect &amp; useEffect</h2><p>在<a class=" " href="https://reactjs.org/docs/hooks-intro.html">官方文档</a> 中已经详细的介绍了各个 hook 的区别。</p><p>官方介绍是这样说的：</p><p>The signature is identical to useEffect, but it fires synchronously after all DOM mutations.
Use this to read layout from the DOM and synchronously re-render.
Updates scheduled inside useLayoutEffect will be flushed synchronously, <code>before the browser has a chance to paint</code>.</p><p>Tip</p><p>If you’re migrating code from a class component, note useLayoutEffect fires in the same phase as componentDidMount and componentDidUpdate.
However, we recommend starting with useEffect first and only trying useLayoutEffect if that causes a problem.</p><p>If you use server rendering, keep in mind that neither useLayoutEffect nor useEffect can run until the JavaScript is downloaded.
This is why React warns when a server-rendered component contains useLayoutEffect.
To fix this, either move that logic to useEffect (if it isn’t necessary for the first render),
or delay showing that component until after the client renders (if the HTML looks broken until useLayoutEffect runs).</p><p>To exclude a component that needs layout effects from the server-rendered HTML,
render it conditionally with <code>showChild &amp;&amp; &lt;Child /&gt;</code> and defer showing it with useEffect(() =&gt; { setShowChild(true); }, []).
This way, the UI doesn’t appear broken before hydration.</p><p>这是在 <code>useLayoutEffect</code> 中介绍的。</p><p><a class=" " href="https://reactjs.org/docs/hooks-reference.html#useeffect">useEffect</a> 的介绍参考官网。</p><p>其中在 <code>useLayoutEffect</code> 中的介绍有几点需要关注的。首先 <code>it fires synchronously after all DOM mutations</code>, 同步触发。
第二 <code>Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint</code>
在浏览器有机会绘画之前。</p><p>那这个到底适合于什么样的场景呢？不如先从一个例子来分析, 假设此时有一个搜索历史的的需求，搜索过的内容需要增加到搜索历史中。并且搜索历史不能超过
一行，超过了一行则进行截取，把超过的那部分去掉。</p><div><img src="./static/media/his.a2578714.jpg"/></div><p>此时我们应该如何去做。基本做法应该是点击搜索，在 <code>useEffect</code> 里进行计算已渲染的历史的节点的宽度，然后遍历历史的 dom 节点进行宽度相加，最后来判断
是否超过了最大宽度，如果超过了最大宽度，那么进行截取，否则不进行截取。（当然如果要是能提前知道 <code>input</code> 输入的内容区的宽度，那么就可以在事件函数中进行提前判断处理)。
目前处理是在 <code>useEffect</code> 中进行遍历来计算宽度的。这个看起来是没有问题的，对吧。不妨看一下效果</p><div><img src="./static/media/useEffect.578d1fbd.gif"/></div><p>可以很容易的看到，有一个闪动的过程，因为在 useEffect 中进行了截取，此时这个 dom 已经被渲染到页面上了。在进行截取，就会看到<code>闪动</code>的现象。</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextHistory <span class="token operator">=</span> <span class="token function">getNextHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">saveHistory</span><span class="token punctuation">(</span>nextHistory<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>history<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> getNextHistory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> cloneHistory <span class="token operator">=</span> history<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> totalWidth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> historyRefs<span class="token punctuation">.</span>current<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> node <span class="token operator">=</span> historyRefs<span class="token punctuation">.</span>current<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> width <span class="token punctuation">}</span> <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      totalWidth <span class="token operator">+=</span> width <span class="token operator">+</span> offset<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>totalWidth <span class="token operator">></span> <span class="token constant">MAX_HISTORY_LENGTH</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cloneHistory <span class="token operator">=</span> cloneHistory<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> cloneHistory<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>那如果换成 <code>useLayoutEffect</code> 呢？</p><div><img src="./static/media/useLayoutEffect.3545cf97.gif"/></div><p>可以看出在使用 <code>useLayoutEffect</code> 的时候之前的闪动不存在了。回头看一下之前标记的地方。其中有一处吃这样的</p><p><code>Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint</code></p><p>所以针对出现需要频繁修改 dom 或者需要在 dom 渲染后又要立马操作 dom 的以及进行一些布局操作的都可以使用 <code>useLayoutEffect</code>。比如 <code>Popover</code>,
<code>ToolTip</code>, <code>DronDown</code> 等相关组件。</p></div><footer class="BlogPostLayout_footer__1p0Ii"><h3 class="BlogPostLayout_title__1egAZ"><a class=" " href="/">lanyincao</a></h3><div class="
      Bio_Bio__1eiKY
      BlogPostLayout_bio__2AHhA
    "><img src="./static/media/bio-pic.fdbb64ab.jpeg" alt="lanyincao"/><p>Personal blog by <a href="https://twitter.com/lanyincao">lanyincao</a>.<br/>I can&#x27;t sing, dance, rap but can code, 🏀</p></div><section class="BlogPostLayout_links__1fVhZ"><a class=" " href="/posts/2019-10-02/the-dep-of-use-hook/">← <!-- -->the dep of useHook</a><a class="BlogPostLayout_next__3tOcG " href="/posts/2019-09-06/the-rule-of-react/">The Rules of React<!-- --> →</a></section></footer></article></main></div></div><script>!function(o){function e(e){for(var t,r,n=e[0],c=e[1],f=e[2],d=0,a=[];d<n.length;d++)r=n[d],l[r]&&a.push(l[r][0]),l[r]=0;for(t in c)Object.prototype.hasOwnProperty.call(c,t)&&(o[t]=c[t]);for(p&&p(e);a.length;)a.shift()();return i.push.apply(i,f||[]),u()}function u(){for(var e,t=0;t<i.length;t++){for(var r=i[t],n=!0,c=1;c<r.length;c++){var f=r[c];0!==l[f]&&(n=!1)}n&&(i.splice(t--,1),e=s(s.s=r[0]))}return e}var r={},a={43:0},l={43:0},i=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return o[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(i){var e=[];a[i]?e.push(a[i]):0!==a[i]&&{1:1,23:1}[i]&&e.push(a[i]=new Promise(function(e,n){for(var t="static/css/"+({}[i]||i)+"."+{1:"27c8494b",2:"31d6cfe0",3:"31d6cfe0",4:"31d6cfe0",5:"31d6cfe0",6:"31d6cfe0",7:"31d6cfe0",8:"31d6cfe0",9:"31d6cfe0",10:"31d6cfe0",11:"31d6cfe0",12:"31d6cfe0",13:"31d6cfe0",14:"31d6cfe0",15:"31d6cfe0",16:"31d6cfe0",17:"31d6cfe0",18:"31d6cfe0",19:"31d6cfe0",20:"31d6cfe0",21:"31d6cfe0",22:"31d6cfe0",23:"d3b34b05",24:"31d6cfe0",25:"31d6cfe0",26:"31d6cfe0",27:"31d6cfe0",28:"31d6cfe0",29:"31d6cfe0",30:"31d6cfe0",31:"31d6cfe0",32:"31d6cfe0",33:"31d6cfe0",34:"31d6cfe0",35:"31d6cfe0",36:"31d6cfe0",37:"31d6cfe0",38:"31d6cfe0",39:"31d6cfe0",40:"31d6cfe0",41:"31d6cfe0"}[i]+".chunk.css",c=s.p+t,r=document.getElementsByTagName("link"),f=0;f<r.length;f++){var d=(o=r[f]).getAttribute("data-href")||o.getAttribute("href");if("stylesheet"===o.rel&&(d===t||d===c))return e()}var a=document.getElementsByTagName("style");for(f=0;f<a.length;f++){var o;if((d=(o=a[f]).getAttribute("data-href"))===t||d===c)return e()}var u=document.createElement("link");u.rel="stylesheet",u.type="text/css",u.onload=e,u.onerror=function(e){var t=e&&e.target&&e.target.src||c,r=new Error("Loading CSS chunk "+i+" failed.\n("+t+")");r.request=t,n(r)},u.href=c,document.getElementsByTagName("head")[0].appendChild(u)}).then(function(){a[i]=0}));var r=l[i];if(0!==r)if(r)e.push(r[2]);else{var t=new Promise(function(e,t){r=l[i]=[e,t]});e.push(r[2]=t);var n,c=document.getElementsByTagName("head")[0],f=document.createElement("script");f.charset="utf-8",f.timeout=120,s.nc&&f.setAttribute("nonce",s.nc),f.src=s.p+"static/js/"+({}[i]||i)+"."+{1:"18016ef5",2:"f51ae852",3:"2d812e0c",4:"959e45b9",5:"031228ef",6:"da64b01a",7:"c20265b4",8:"3708fc80",9:"76d5a1f1",10:"64d279dc",11:"15bdaa3d",12:"a289339e",13:"6ed3fae5",14:"c0219476",15:"1b2dfa34",16:"c95df50e",17:"854d2668",18:"fe4e0156",19:"75b2ab08",20:"5cc3e2dd",21:"85a6bb34",22:"f5b6dab9",23:"873b678f",24:"299ad1b2",25:"26732315",26:"8ed938bb",27:"9e08b9c8",28:"8c5bf47d",29:"651315e7",30:"4de03612",31:"a827ef55",32:"9f8e8c89",33:"4e98a6ac",34:"8fa7acd9",35:"f7fd16e7",36:"c8a9136e",37:"7fd46dad",38:"ab859197",39:"242ef20f",40:"a8b763a6",41:"fe59cd2f"}[i]+".chunk.js",n=function(e){f.onerror=f.onload=null,clearTimeout(d);var t=l[i];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),n=e&&e.target&&e.target.src,c=new Error("Loading chunk "+i+" failed.\n("+r+": "+n+")");c.type=r,c.request=n,t[1](c)}l[i]=void 0}};var d=setTimeout(function(){n({type:"timeout",target:f})},12e4);f.onerror=f.onload=n,c.appendChild(f)}return Promise.all(e)},s.m=o,s.c=r,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(r,n,function(e){return t[e]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="./",s.oe=function(e){throw console.error(e),e};var t=window.webpackJsonp=window.webpackJsonp||[],n=t.push.bind(t);t.push=e,t=t.slice();for(var c=0;c<t.length;c++)e(t[c]);var p=n;u()}([])</script><script src="./static/js/42.e4ff5a7a.chunk.js"></script><script src="./static/js/main.ec82054e.chunk.js"></script></body></html>